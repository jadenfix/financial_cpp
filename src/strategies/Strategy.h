#pragma once

#include "../core/Event.h" // Use relative paths
#include "../core/EventQueue.h"
#include <string>
#include <vector>
#include <map>

class Strategy {
public:
    virtual ~Strategy() = default;

    // Called by the Backtester to process new market data
    // The strategy should calculate indicators and potentially generate Signal or Order events
    virtual void handle_market_event(const MarketEvent& event, EventQueue& queue) = 0;

    // Called by the Backtester when one of the strategy's orders gets filled
    // Allows the strategy to update its internal state (e.g., entry price, position size)
    virtual void handle_fill_event(const FillEvent& event) {
        // Default implementation does nothing, override if needed
        (void)event; // Suppress unused variable warning
    }

    // Optional: Called when a signal generated by this strategy is processed
    // virtual void handle_signal_event(const SignalEvent& event) {}

    // Optional: Called when an order generated by this strategy is processed
    // virtual void handle_order_event(const OrderEvent& event) {}

protected:
    // Helper to push events onto the queue
    void send_event(EventPtr event, EventQueue& queue) {
        queue.push(std::move(event));
    }

    // Strategies might need access to historical bars for indicator calculations
    // This implies either storing history within the strategy or having access to it elsewhere
    // For now, let's assume strategies manage their needed history/indicators internally.
};